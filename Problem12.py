"""
The sequence of triangle numbers is generated by adding the natural numbers.
So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28.
The first ten terms would be:

1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

Let us list the factors of the first seven triangle numbers:

 1: 1
 3: 1,3
 6: 1,2,3,6
10: 1,2,5,10
15: 1,3,5,15
21: 1,3,7,21
28: 1,2,4,7,14,28

We can see that 28 is the first triangle number to have over five divisors.
What is the value of the first triangle number to have over five hundred divisors?

"""
import collections
import time

#
# Function prime_fac returns a list of all the prime factors of a positive integer
# I just re-used code from Project Euler problem #3
# Perhaps I should save all these to a library so I can simply import and re-use?
#
def prime_fac(n):

    factors = []

    d = 2

    while n > 1:

        while n % d == 0:

            factors.append(d)

            n /= d

        d = d + 1

        if d*d > n:

            if n > 1: factors.append(n)

            break

    return factors

# This function returns triangle numbers ---------------------------------
# The nth triangle number is the number of dots composing a triangle with n dots on a side.
#
# http://en.wikipedia.org/wiki/Triangular_number
#
def triangle_num(Tn):

    Tn = Tn * (Tn + 1)/2 # definition of a triangle number

    return Tn

# This function counts divisors ------------------------------------------
# We can use the prime factorization of a number n to find all of its divisors up to n/2.
# In this case, we use Tn for "triangle number"
def count_divs(Tn):

    list_of_primes = prime_fac(Tn) # find the prime factorization and store in variable prime

    #
    # The method Counter takes a list of prime factors and groups them
    # e.g., 16 = [2,2,2,2] would be

    counter = collections.Counter(list_of_primes)

    #
    # here's the magic bit d(n)=(v1+1)(v2+1)...(vk+1)
    # The formula above counts the number of divisors of a given number
    #
    # http://mathworld.wolfram.com/DivisorFunction.html
    #
    # Then, we only need to sum the primes up to the 23rd one ... given the size of the problem
    # I probably could clean this up a bit ...
    #
    sum = (counter[2]+1)*(counter[5]+1)*(counter[3]+1)*(counter[7]+1)*(counter[11]+1)*(counter[13]+1)*(counter[17]+1)*(counter[19]+1)*(counter[23]+1)

    return sum
"""

Now, onto the problem at hand ...

Numbers such that d(n), the number of divisors of n, is larger than
for any smaller n are called highly composite numbers.

http://en.wikipedia.org/wiki/Highly_composite_number

If N=2^(a_2)3^(a_3)...p^(a_p) is the prime factorization of a number, then the following
are features of a highly composite number:
1. The primes 2, 3, ..., p form a string of consecutive primes,
2. The exponents are non-increasing, so a**2 >= a**3 >= ... >= a**p, and
3. The final exponent a_p is always 1, except for the two cases N=4=2^2
and N=36=2^2*3^2, where it is 2.

If n is a triangular number, then it can be termed as a "Highly Composite Triangular
Number"

For example: 28 is a triangular number and d(28) = 6 . The number of divisors
of all triangular numbers less than 28 is less than 6. So 28 is a Highly Composite
Triangular number.

"""

#
# Let's declare some variables
#

starttime = time.time()
Tn = 6000

# while loop ... runs while the count of divisors is < 500.  Once the counter
# goes over 500, exit the while loop

while count_divs(triangle_num(Tn)) < 500:

    Tn += 1

# print out the result

print triangle_num(Tn), "has", count_divs(triangle_num(Tn)), "divisors"
print "Answer found in", time.time() - starttime, "seconds"